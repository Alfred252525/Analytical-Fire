#!/usr/bin/env python3
"""
Dependency Vulnerability Scanning - Automated vulnerability detection
Implements SOC 2 compliance vulnerability management requirements
"""

import os
import sys
import subprocess
import json
from datetime import datetime
from typing import List, Dict, Optional

# Severity levels
SEVERITY_LEVELS = {
    'CRITICAL': 1,
    'HIGH': 2,
    'MEDIUM': 3,
    'LOW': 4
}


class DependencyVulnerabilityScanner:
    """Scan dependencies for vulnerabilities"""
    
    def __init__(self, requirements_file: str = None):
        """
        Initialize vulnerability scanner
        
        Args:
            requirements_file: Path to requirements.txt (default: backend/requirements.txt)
        """
        if requirements_file is None:
            script_dir = os.path.dirname(__file__)
            requirements_file = os.path.join(script_dir, '..', 'backend', 'requirements.txt')
        
        self.requirements_file = requirements_file
        
        if not os.path.exists(self.requirements_file):
            raise FileNotFoundError(f"Requirements file not found: {self.requirements_file}")
    
    def check_pip_audit_available(self) -> bool:
        """Check if pip-audit is available"""
        try:
            result = subprocess.run(
                ['pip-audit', '--version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False
    
    def check_safety_available(self) -> bool:
        """Check if safety is available"""
        try:
            result = subprocess.run(
                ['safety', '--version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False
    
    def scan_with_pip_audit(self) -> List[Dict]:
        """
        Scan dependencies using pip-audit
        
        Returns:
            List of vulnerability dictionaries
        """
        vulnerabilities = []
        
        try:
            result = subprocess.run(
                ['pip-audit', '--requirement', self.requirements_file, '--format', 'json'],
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                try:
                    data = json.loads(result.stdout)
                    for vuln in data.get('vulnerabilities', []):
                        vulnerabilities.append({
                            'package': vuln.get('name', 'Unknown'),
                            'installed_version': vuln.get('installed_version', 'Unknown'),
                            'vulnerability_id': vuln.get('id', 'Unknown'),
                            'severity': self._normalize_severity(vuln.get('severity', 'UNKNOWN')),
                            'description': vuln.get('description', 'No description'),
                            'fix_version': vuln.get('fix_versions', [None])[0] if vuln.get('fix_versions') else None,
                            'source': 'pip-audit'
                        })
                except json.JSONDecodeError:
                    print(f"⚠️  Could not parse pip-audit JSON output")
            
        except subprocess.TimeoutExpired:
            print("⚠️  pip-audit scan timed out")
        except Exception as e:
            print(f"⚠️  Error running pip-audit: {e}")
        
        return vulnerabilities
    
    def scan_with_safety(self) -> List[Dict]:
        """
        Scan dependencies using safety
        
        Returns:
            List of vulnerability dictionaries
        """
        vulnerabilities = []
        
        try:
            result = subprocess.run(
                ['safety', 'check', '--file', self.requirements_file, '--json'],
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode != 0:  # Safety returns non-zero on vulnerabilities
                try:
                    data = json.loads(result.stdout)
                    for vuln in data:
                        vulnerabilities.append({
                            'package': vuln.get('package_name', 'Unknown'),
                            'installed_version': vuln.get('installed_version', 'Unknown'),
                            'vulnerability_id': vuln.get('vulnerability_id', 'Unknown'),
                            'severity': self._normalize_severity(vuln.get('severity', 'UNKNOWN')),
                            'description': vuln.get('advisory', 'No description'),
                            'fix_version': vuln.get('fixed_versions', [None])[0] if vuln.get('fixed_versions') else None,
                            'source': 'safety'
                        })
                except json.JSONDecodeError:
                    # Safety might output text format
                    print(f"⚠️  Could not parse safety JSON output")
        
        except subprocess.TimeoutExpired:
            print("⚠️  safety scan timed out")
        except Exception as e:
            print(f"⚠️  Error running safety: {e}")
        
        return vulnerabilities
    
    def _normalize_severity(self, severity: str) -> str:
        """Normalize severity to standard levels"""
        severity_upper = severity.upper()
        
        if 'CRITICAL' in severity_upper or 'CRIT' in severity_upper:
            return 'CRITICAL'
        elif 'HIGH' in severity_upper:
            return 'HIGH'
        elif 'MEDIUM' in severity_upper or 'MODERATE' in severity_upper:
            return 'MEDIUM'
        elif 'LOW' in severity_upper:
            return 'LOW'
        else:
            return 'UNKNOWN'
    
    def scan(self) -> Dict:
        """
        Scan dependencies for vulnerabilities
        
        Returns:
            Dictionary with scan results
        """
        print("=" * 60)
        print("Dependency Vulnerability Scan")
        print("=" * 60)
        print(f"Requirements file: {self.requirements_file}")
        print(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print()
        
        all_vulnerabilities = []
        
        # Try pip-audit first
        if self.check_pip_audit_available():
            print("Scanning with pip-audit...")
            vulns = self.scan_with_pip_audit()
            all_vulnerabilities.extend(vulns)
            print(f"  Found {len(vulns)} vulnerabilities")
        else:
            print("⚠️  pip-audit not available (install with: pip install pip-audit)")
        
        # Try safety as backup
        if self.check_safety_available():
            print("Scanning with safety...")
            vulns = self.scan_with_safety()
            # Merge vulnerabilities (avoid duplicates)
            existing_packages = {v['package'] for v in all_vulnerabilities}
            for vuln in vulns:
                if vuln['package'] not in existing_packages:
                    all_vulnerabilities.append(vuln)
            print(f"  Found {len([v for v in vulns if v['package'] not in existing_packages])} additional vulnerabilities")
        else:
            print("⚠️  safety not available (install with: pip install safety)")
        
        # Deduplicate by package + vulnerability_id
        seen = set()
        unique_vulnerabilities = []
        for vuln in all_vulnerabilities:
            key = (vuln['package'], vuln['vulnerability_id'])
            if key not in seen:
                seen.add(key)
                unique_vulnerabilities.append(vuln)
        
        # Group by severity
        by_severity = {
            'CRITICAL': [],
            'HIGH': [],
            'MEDIUM': [],
            'LOW': [],
            'UNKNOWN': []
        }
        
        for vuln in unique_vulnerabilities:
            severity = vuln['severity']
            by_severity[severity].append(vuln)
        
        # Print summary
        print()
        print("=" * 60)
        print("Scan Results")
        print("=" * 60)
        print(f"Total vulnerabilities: {len(unique_vulnerabilities)}")
        print(f"  Critical: {len(by_severity['CRITICAL'])}")
        print(f"  High: {len(by_severity['HIGH'])}")
        print(f"  Medium: {len(by_severity['MEDIUM'])}")
        print(f"  Low: {len(by_severity['LOW'])}")
        print(f"  Unknown: {len(by_severity['UNKNOWN'])}")
        print()
        
        # Print details
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            if by_severity[severity]:
                print(f"{severity} Severity Vulnerabilities:")
                for vuln in by_severity[severity]:
                    print(f"  - {vuln['package']} ({vuln['installed_version']})")
                    print(f"    ID: {vuln['vulnerability_id']}")
                    if vuln['fix_version']:
                        print(f"    Fix: Upgrade to {vuln['fix_version']}")
                    print(f"    Description: {vuln['description'][:100]}...")
                    print()
        
        return {
            'scan_date': datetime.now().isoformat(),
            'requirements_file': self.requirements_file,
            'total_vulnerabilities': len(unique_vulnerabilities),
            'by_severity': {k: len(v) for k, v in by_severity.items()},
            'vulnerabilities': unique_vulnerabilities,
            'compliant': len(by_severity['CRITICAL']) == 0 and len(by_severity['HIGH']) == 0
        }


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Dependency Vulnerability Scanner')
    parser.add_argument('--requirements', type=str, help='Path to requirements.txt')
    parser.add_argument('--json', action='store_true', help='Output results as JSON')
    
    args = parser.parse_args()
    
    scanner = DependencyVulnerabilityScanner(requirements_file=args.requirements)
    results = scanner.scan()
    
    if args.json:
        print(json.dumps(results, indent=2))
    
    # Exit with error code if critical/high vulnerabilities found
    if not results['compliant']:
        sys.exit(1)


if __name__ == "__main__":
    main()
